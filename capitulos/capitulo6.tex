\chapter{Resultados}
\label{chapter:Resultados}

\section{O framework}

O SocialFramework é uma \textit{engine} do Rails que ajuda a construir redes sociais com recursos comuns e específicos.

O SocialFramework é dividido em três módulos, que são: usuários, rotas e agendas. No módulo de usuários são providos os principais recursos para usuários, como autenticação, registro e pesquisas. No módulo de rotas o \textit{framework} provê recursos para checar a compatibilidade de rotas. No módulo de agenda são oferecidos recursos para definir agendas de usuários e a compatibilidade de horário entre usuários.

Portanto, o SocialFramework pode ajudar a construir redes sóciais genéricas e específicas de um modo rápido e prático e sem se preocupar com problemas recorrentes nestes tipos de sistemas.

\subsection{Instalação}

A instalação do SocialFramework possui dois passos simples.

Primeiro adicione a seguinte linha no arquivo Gemfile:

\begin{lstlisting}[
    label=listing:Gemfile,
    caption=Gemfile,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
gem 'social_framework'
\end{lstlisting}

Após a adição da \textit{gem} no Gemfile, instale-o executando o seguinte comando:

\begin{lstlisting}[
    label=listing:Install,
    caption=Instalação,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ bundle install
\end{lstlisting}

Isto irá instalar o SocialFramework na aplicação.

\subsection{Primeiros passos}

O SocialFramework utiliza o Devise, que é uma solução de autenticação flexível para Rails. Para visualizar a documentação completa do Devise acesse: \url{https://github.com/plataformatec/devise}. A classe de usuário foi implementada no SocialFramework e possui algumas diferenças da classe de usuário padrão do Devise, como a adição do atributo nome e dos relacionamentos dos usuários. As \textit{controllers} e \textit{views} do Devise também foram alteradas para adicionar os novos recursos.

Inicialmente, alguns arquivos devem ser adicionado na aplicação para que configurações do SocialFramework e do Devise sejam adicionadas. Esses arquivos são os \textit{initializers}, o arquivo de internacionalização (i18n) do Devise, as rotas e as \textit{views} de \textit{registration} e \textit{session} para criar e autenticar usuários. Para isso deve-se executar:

\begin{lstlisting}[
    label=listing:generate_social_framework,
    caption=Gerando as configurações do SocialFramework e do Devise,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ rails generate social_framework:install
\end{lstlisting}

Este comando irá criar o arquivo ``config/initializers/devise.rb'' contendo as configurações do Devise, o arquivo ``config/initializers/social\_framework.rb'' que contem as configurações do SocialFramework, o arquivo i18n do Devise e irá adicionar a rota ``devise\_for'' para mapear as \textit{controllers} e \textit{views} do Devise. Com isto a aplicação está preparada para usuar o módulo de usuários com as configurações e comportamentos padrões.

Para testar a aplicação não se deve esquecer de executar as migrations:

\begin{lstlisting}[
    label=listing:migrations,
    caption=Migrations,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ rake db:create
$ rake db:migrate
\end{lstlisting}

Todas as tabelas do \textit{framework} serão criadas no banco de dados da aplicação.

Para acessar a página de autenticação acesse a rota ``/users/sing\_in'', esta página está preparada para autenticar usuários com \textit{email} ou nome de usuário. Para cadastrar um novo usuário deve-se acessar a rota ``/users/sing\_up'', ao criar um novo usuário você estará automaticamente conectado.

Quando se usa o Devise Mailer como o Módulo confirmável é necessário adicionar em seu ambiente as configurações para a ação \textit{mailer}, por exemplo, se estiver no ambiente de desenvolvimento deve-se adicionar as seguintes configurações no arquivo `development.rb'.

\begin{lstlisting}[
    label=listing:mailer,
    caption=Configurações de email,
    numbers=left,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
config.action_mailer.default_url_options = {host: 'localhost', port: 3000}

config.action_mailer.delivery_method = :smtp

config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: ENV["GMAIL_DOMAIN"],
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
\end{lstlisting}

Pode-se alterar os valores em `domain', `user\_name', e `password' ou criar as variáveis de ambiente locais, isso é indicado para esconder essas informações sigilosas e garantir uma maior segurança. As mesmas configurações são válidas para os ambientes de teste e produção, nos arquivos `test.rb' e `production.rb'.

\subsection{Helpers e filtros das controllers}

O Devise fornece alguns elementos para serem usados nas \textit{controllers} e \textit{views}. Para configurar uma \textit{controller} com uma autenticação de usuário basta adicionar o seguinte \textit{before\_action}, isto funciona porque o SocialFramework já contem a classe de usuário.

\begin{lstlisting}[
    label=listing:authenticate,
    caption=Requer autenticação de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
before_action :authenticate_user!
\end{lstlisting}

Outros elementos são:

\begin{lstlisting}[
    label=listing:signed_in,
    caption=Verifica se o usuário está logado,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
user_signed_in?
\end{lstlisting}

\begin{lstlisting}[
    label=listing:current_user,
    caption=Recupera o usuário logado,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
current_user
\end{lstlisting}

\begin{lstlisting}[
    label=listing:user_session,
    caption=Recupera a sessão para este escopo,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
user_session
\end{lstlisting}

Após o usuário logar, confirmar a conta ou atualizar a senha o Devise irá procurar por uma caminho \textit{root} para redirecionar. Para alterar esse comportamento padrão, pode-se sobrescrever os métodos ``after\_sing\_in\_path\_for'' e ``after\_sing\_out\_path\_for''.

\subsection{Configuração das modelos}

A classe de usuário no SocialFramework implementa os módulos padrões do Devise. Na documentação completa do Devise é possível encontrar todos os módulos e suas características.

Além dos módulos do Devise, a classe de usuário do SocialFramework possui métodos quem implementam os comportamentos para os relacionamentos de usuários. É possível sobrescrever qualquer comportamento extendendo a classe em outra modelo, como:

\begin{lstlisting}[
    label=listing:extensao_user_class,
    caption=Extensão da classe de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class OtherUserClass < SocialFramework::User
  # Your code goes here
end
\end{lstlisting}

É necessário mudar o nome da classe no arquivo ``routes.rb'' para a nova classe criada, assim o Devise poderá enxergar a nova classe. Para fazer isso:

\begin{lstlisting}[
    label=listing:devise_new_user_class,
    caption=Configurando a nova classe de usuário para o Devise,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
devise_for :users, class_name: 'OtherUserClass',
    controllers: {sessions: 'users/sessions',
                  registrations: 'users/registrations',
                  passwords: 'users/passwords'}
\end{lstlisting}

\subsection{Configuração das migrations}

A classe de usuário fornece como padrão os atributos nome de usuário, e-mail e senha. Para adicionar ou remover atributos para esta ou qualquer outra classe pode-se adicionar a \textit{migrate} na aplicação. O SocialFramework dispõe de um gerador para fazer isso, neste caso só é necessário executar:

\begin{lstlisting}[
    label=listing:generate_migrate,
    caption=Geração das migrations,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:install_migrations -m users
\end{lstlisting}

A \textit{migrate} de usuário será adicionada na aplicação e poderá ser alterada. O parâmetro `m' é usado para gerar \textit{migrations} específicas, o \textit{script} espera os nomes das \textit{migrations}. Caso não exista a migration na aplicação, esta será gerada.

Caso seja adicionado ou removido um atributo para o usuário deve-se notificar o Devise, usando um filtro \textit{before} na ``ApplicationController'':

\begin{lstlisting}[
    label=listing:user_attribute,
    caption=Configuração para adicionar um novo atributo de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.for(:sign_up) << :new_attribute
    devise_parameter_sanitizer.for(:account_update) << :new_attribute
  end
end
\end{lstlisting}

Isto faz com que o \textit{sign\_up} e o \textit{account\_update} receba o novo atributo. Pode-se usar o método de remoção para remover os atributos existentes. Para adiconar ou remover o parâmetor em outras ações, por exemplo o \textit{sign\_in}, deve-se fazer o mesmo procedimento.

\subsection{Configuração das controllers}

Todas as \textit{controllers} do Devise podem ser extendidas e ter o seus métodos sobrescritos. Por exemplo:

\begin{lstlisting}[
    label=listing:extensao_controller,
    caption=Extensão de uma controller,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class OtherRegistrationControllerClass < Users::RegistrationsController
  # Your code goes here
end
\end{lstlisting}

Outras \textit{controllers} são: ``confirmations'', ``omniauth\_callbacks'', ``passwords'', ``sessions'' e ``unlocks''. Para usar os módulos de ``omniauth\_callbacks'', ``unlocks'' e ``confirmations'' é necessário adicionar esses respectivos módulos do Devise na aplicação. Todas as \textit{controllers} do Devise no SocialFramework possuem o prefixo ``Users''.

\subsection{Configuração das rotas}

Quando se substitui algumas \textit{controllers} do Devise deve-se definir essas novas \textit{controllers} nas rotas. Isto pode ser feito alterando o caminho para a \textit{controller} na configuração \textit{devise\_for}, como no exemplo a seguir:

\begin{lstlisting}[
    label=listing:configuracao_controller,
    caption=Configuração de uma controller,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
devise_for :users, class_name: 'SocialFramework::User',
  controllers: {sessions: 'users/sessions',
                registrations: 'new_registration_controller_path',
                passwords: 'users/passwords'}
\end{lstlisting}

A \textit{controller} de registro foi extendida e a nova \textit{controller} foi adicionada nas configurações de rotas do Devise.

\subsection{Configuração das views}

Para adicionar as \textit{views} do Devise na aplicação o SocialFramework um gerador para executar esta tarefa, para executa-lo deve-se usar o seguinte comando:

\begin{lstlisting}[
    label=listing:gerar_views,
    caption=Geração das views,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:views
\end{lstlisting}

Para adicionar uma \textit{view} específica deve-se usar o parâmetro `-v' e passar o nome das \textit{views}, como no exemplo a seguir:

\begin{lstlisting}[
    label=listing:gerar_views,
    caption=Geração das views,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:views -v registrations sessions passwords
\end{lstlisting}

Este comando irá adicionar as \textit{views} ``registrations'', ``sessions'' e ``passwords'' na aplicação. As outras \textit{views} são: ``confirmations'', ``mailer'' and ``unlocks''. Inicialmente, o SocialFramework adiciona as \textit{views} registrations e sessions na aplicação fornecendo autenticação e registro para os usuários.

\subsection{Módulos do SocialFramework}

Atualmente o SocialFramework possui os módulos de usuário, de rotas e de agendas.

\subsubsection{Módulo de usuários}

Este módulo fornece a lógica principal à redes sociais, como criar, confirmar e remover relacionamentos entre os usuários, além de buscas, registros, atualizações e autenticações.

A estrutura de relacionamentos foi construída com um relacionamento de muitos para muitos entre usuários através de arestas. As aresta possuem o usuário de origem, o usuário de destino, o \textit{status}, pode estar ativo ou inativo, se é bidirecional ou não, que  especifica relacionamentos como bidirecional ou unidirecional, e um rótulo com o nome do relacionamento. Pode-se existir múltiplas relacionamentos entre os mesmos usuários. Cada relacionamento é representar com uma aresta.

Para criar um novo relacionamento entre dois usuários deve-se utilizar o método `create\_relationship' definido na classe de usuário. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:create_relationship,
    caption=Método para criar relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
create_relationship(destiny, label, bidirectional=true, active=false)
\end{lstlisting}

O usuário que pede o relacionamento deve chamar este método e passar o usuário de destino e rótulo para o relacionamento. Por padrão é criada um relacionamento bidirecional e inativa entre esse usuários. É possível mudar esse comportamento passando os outros parâmetros para o método.

Para ativar o relacionamento criado é necessário uma confirmaçaõ. Para confirmar de usuário de destino deve invocar o método `confirm\_relationship'. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:confirm_relationship,
    caption=Método para confirmar relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
confirm_relationship(user, label)
\end{lstlisting}

É necessário passar como parâmetro o usuário de origem e o rótulo com o tipo de relacionamento. O único usuário que pode confirmar o relacionamento é o usuário de destino.

Para remover algum relacionamento, os usuários devem chamar o método `remove\_relationship', passando o outro usuário no relacionamento e o rótulo do relacionamento. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
remove_relationship(destiny, label)
\end{lstlisting}

A classe de usuário fornece também um método para obter os usuários que estão relacionados com um usuário, para isso deve-se invocar o seguinte método:

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
relationships(label, status = true, created_by = "any")
\end{lstlisting}

O ``label'' representa com qual tipo de relacionamento se deseja obter os usuários, o ``status'' é usado para os usuários com relacionamentos ativos ou inativos, o padrão é \textit{true}, o parâmetro ``created\_by'' é usado para especificar qual usuário pode ter criado o relacionamento, se for `any' qualquer usuário poderá ter criado o relacionamento, se for ``self'' os relacionamentos devem possuir como usuário de origem o próprio usuário ou se for ``other'' os relacionamentos devem possuir como usuário de destino o próprio usuário.

O módulo de usuários usa um grafo para fornecer algumas funcionalidades, como buscas na rede e sugestão de relacionamentos. Todas estas funcionalidades estão presentes no ``NetworkHelper'' que implementa as classes ``Graph'', ``Vertex'' e ``Edge''. O gráfico pode ser acessado a partir do método `graph', que está prensente na classe de usuário. Na ação \textit{sign\_in} o grafo é construido com o usuário logado como \textit{root}. O grafo é construído até que a profundidade especificada no \textit{initializer} `social\_framework.rb' na variável `depth\_to\_build', o valor padrão é de três. O método `graph' possui a seguinte assinatura.

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
build(root, attributes = [:username, :email, :title], relationships = "all")
\end{lstlisting}

O parametro ``root'' é um usuário que irá ser a raiz do grafo, o parâmetro ``attributes'' corresponde aos atributos de usuário e evento que serão mapeados para os vértices, por padrão contém `username', `email' e `title'. Os relacionamentos são o tipo de relacionamentos que serão utilizados para a construção do grafo, deve ser uma \textit{string} ou um \textit{array}, caso seja passado ``any'' o grafo é construido com qualquer relacionamento. Na ação \textit{sign\_in} o grafo é construído com atributos `username', `email' e `title', além de `id'.

Com o grafo construído é possível sugerir relações. Para isso, analisa-se o terceiro nível do grafo para encontrar relacionamentos comuns com o tipo especificado no \textit{initialize} `social\_framework.rb' na variável `relationship\_type\_to\_suggest', o valor padrão é ``friend'', a variável `amount\_relationship\_to\_suggest' especifica a quantidade de relacionamentos para fazer a sugestão, o valor padrão é de cinco. Esse método possui a seguinte assinatura.

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
suggest_relationships(type_relationships = SocialFramework.relationship_type_to_suggest,
  amount_relationships = SocialFramework.amount_relationship_to_suggest)
\end{lstlisting}

Considerando os valores padrão, se um usuário `A' e um usuário `C' tem cinco relacionamento com o tipo de ``friend'' com outros cinco usuários o sistema irá sugerir ao usuário `A' começar o mesmo relacionamento com o usuário `C'.

A busca no grafo é executado usando o algoritmo BFS. O método da busca possui a seguinte assinatura.

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
search(map, search_in_progress = false, elements_number = SocialFramework.elements_number_to_search)
\end{lstlisting}

É passado um mapa para ser usado na pesquisa, este mapa representa as chaves e valores para comparar com os vértices, por exemplo, o mapa `{username: `user', email: `user', title: `event'}' fará com que uma pesquisa retorne qualquer vértice que contem a \textit{string} `user' no \textit{username} ou email ou que contenha a \textit{string} ``event'' no \textit{title}. O parâmetro `search\_in\_progress' é usado para continuar uma busca para encontrar mais resultados, para continuar deve-se passar \textit{true}. O parâmetro `elements\_number' definir a quantidade de resultados para retornar, este valor é especificado no \textit{initialize} `social\_framework.rb' na variável `elements\_number\_to\_search', o valor padrão é de cinco.

Um exemplo para continuar Pesquisas é mostrado abaixo. Por padrão, quando se continua a procurar o param `elements\_number' é usado para aumentar o tamanho máximo para os resultados encontrados. Neste caso, a primeira chamada retorna os primeiros cinco elementos encontrados no grafo, a segunda chamada retorna mais dez elementos e o tamanho final é quinze. O retorno é um hash com duas chaves, a primeira é ``users'' e seu valor é um \textit{array} usuários, e segunda é ``event" e seu valor é um \textit{array} de eventos encontrados.

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
map = {username: 'user', email: 'user', title: 'event'}
graph.search(map)
graph.search(map, true, 10)
\end{lstlisting}

Pode-se alterar o comportamento padrão para continuar pesquisas passando um bloco para o método, este bloco vai indicar como o ``elements\_number'' deve ser aumentado. Por exemplo:

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
map = {username: 'user', email: 'user', title: 'event'}
graph.search(map, false, 1)
graph.search(map, true) { |elements_number| elements_number *= 2 }
\end{lstlisting}


Nesse caso, o `elements\_number' vai dobrar a cada método de pesquisa chamado com esse bloco. Portanto, a primeira chamada retorna um elemento, devido ao valor passado, o segundo dois, a terceira quatro, e assim por diante.

Quando a pesquisa chega ao fim do grafo e ainda não encontrou todos os elementos necessários uma pesquisa no banco de dados é feito para completar a \textit{hash}.

\subsubsection{Módulo de agendas}

\subsubsection{Módulo de rotas}

\section{Hotspots}

\section{Relatório de testes}

\section{Relatório de qualidade}

\section{Relatório de desempenho}

% \subsecton{Tempo de execução}

% \subsecton{Memória}

\section{Uso da rede social}
