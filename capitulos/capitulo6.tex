\chapter{Resultados}
\label{chapter:Resultados}

\section{O framework}

O SocialFramework é uma \textit{engine} do Rails que ajuda a construir redes sociais com recursos comuns e específicos.

O SocialFramework é dividido em três módulos, que são: usuários, rotas e agendas. No módulo de usuários são providos os principais recursos para usuários, como autenticação, registro e pesquisas. No módulo de rotas o \textit{framework} provê recursos para checar a compatibilidade de rotas. No módulo de agenda são oferecidos recursos para definir agendas de usuários e a compatibilidade de horário entre usuários.

Portanto, o SocialFramework pode ajudar a construir redes sóciais genéricas e específicas de um modo rápido e prático e sem se preocupar com problemas recorrentes nestes tipos de sistemas.

\subsection{Instalação}

A instalação do SocialFramework possui dois passos simples.

Primeiro adicione a seguinte linha no arquivo Gemfile:

\begin{lstlisting}[
    label=listing:Gemfile,
    caption=Gemfile,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
gem 'social_framework'
\end{lstlisting}

Após a adição da \textit{gem} no Gemfile, instale-o executando o seguinte comando:

\begin{lstlisting}[
    label=listing:Install,
    caption=Instalação,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ bundle install
\end{lstlisting}

Isto irá instalar o SocialFramework na aplicação.

\subsection{Primeiros passos}

O SocialFramework utiliza o Devise, que é uma solução de autenticação flexível para Rails. Para visualizar a documentação completa do Devise acesse: \url{https://github.com/plataformatec/devise}. A classe de usuário foi implementada no SocialFramework e possui algumas diferenças da classe de usuário padrão do Devise, como a adição do atributo nome e dos relacionamentos dos usuários. As \textit{controllers} e \textit{views} do Devise também foram alteradas para adicionar os novos recursos.

Inicialmente, alguns arquivos devem ser adicionado na aplicação para que configurações do SocialFramework e do Devise sejam adicionadas. Esses arquivos são os \textit{initializers}, o arquivo de internacionalização (i18n) do Devise, as rotas e as \textit{views} de \textit{registration} e \textit{session} para criar e autenticar usuários. Para isso deve-se executar:

\begin{lstlisting}[
    label=listing:generate_social_framework,
    caption=Gerando as configurações do SocialFramework e do Devise,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ rails generate social_framework:install
\end{lstlisting}

Este comando irá criar o arquivo ``config/initializers/devise.rb'' contendo as configurações do Devise, o arquivo ``config/initializers/social\_framework.rb'' que contem as configurações do SocialFramework, o arquivo i18n do Devise e irá adicionar a rota ``devise\_for'' para mapear as \textit{controllers} e \textit{views} do Devise. Com isto a aplicação está preparada para usuar o módulo de usuários com as configurações e comportamentos padrões.

Para testar a aplicação não se deve esquecer de executar as migrations:

\begin{lstlisting}[
    label=listing:migrations,
    caption=Migrations,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
]
$ rake db:create
$ rake db:migrate
\end{lstlisting}

Todas as tabelas do \textit{framework} serão criadas no banco de dados da aplicação.

Para acessar a página de autenticação acesse a rota ``/users/sing\_in'', esta página está preparada para autenticar usuários com \textit{email} ou nome de usuário. Para cadastrar um novo usuário deve-se acessar a rota ``/users/sing\_up'', ao criar um novo usuário você estará automaticamente conectado.

Quando se usa o Devise Mailer como o Módulo confirmável é necessário adicionar em seu ambiente as configurações para a ação \textit{mailer}, por exemplo, se estiver no ambiente de desenvolvimento deve-se adicionar as seguintes configurações no arquivo `development.rb'.

\begin{lstlisting}[
    label=listing:mailer,
    caption=Configurações de email,
    numbers=left,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
config.action_mailer.default_url_options = {host: 'localhost', port: 3000}

config.action_mailer.delivery_method = :smtp

config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: ENV["GMAIL_DOMAIN"],
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
\end{lstlisting}

Pode-se alterar os valores em `domain', `user\_name', e `password' ou criar as variáveis de ambiente locais, isso é indicado para esconder essas informações sigilosas e garantir uma maior segurança. As mesmas configurações são válidas para os ambientes de teste e produção, nos arquivos `test.rb' e `production.rb'.

\subsection{Helpers e filtros das controllers}

O Devise fornece alguns elementos para serem usados nas \textit{controllers} e \textit{views}. Para configurar uma \textit{controller} com uma autenticação de usuário basta adicionar o seguinte \textit{before\_action}, isto funciona porque o SocialFramework já contem a classe de usuário.

\begin{lstlisting}[
    label=listing:authenticate,
    caption=Requer autenticação de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
before_action :authenticate_user!
\end{lstlisting}

Outros elementos são:

\begin{lstlisting}[
    label=listing:signed_in,
    caption=Verifica se o usuário está logado,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
user_signed_in?
\end{lstlisting}

\begin{lstlisting}[
    label=listing:current_user,
    caption=Recupera o usuário logado,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
current_user
\end{lstlisting}

\begin{lstlisting}[
    label=listing:user_session,
    caption=Recupera a sessão para este escopo,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
user_session
\end{lstlisting}

Após o usuário logar, confirmar a conta ou atualizar a senha o Devise irá procurar por uma caminho \textit{root} para redirecionar. Para alterar esse comportamento padrão, pode-se sobrescrever os métodos ``after\_sing\_in\_path\_for'' e ``after\_sing\_out\_path\_for''.

\subsection{Configuração das modelos}

A classe de usuário no SocialFramework implementa os módulos padrões do Devise. Na documentação completa do Devise é possível encontrar todos os módulos e suas características.

Além dos módulos do Devise, a classe de usuário do SocialFramework possui métodos quem implementam os comportamentos para os relacionamentos de usuários. É possível sobrescrever qualquer comportamento extendendo a classe em outra modelo, como:

\begin{lstlisting}[
    label=listing:extensao_user_class,
    caption=Extensão da classe de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class OtherUserClass < SocialFramework::User
  # Your code goes here
end
\end{lstlisting}

É necessário mudar o nome da classe no arquivo ``routes.rb'' para a nova classe criada, assim o Devise poderá enxergar a nova classe. Para fazer isso:

\begin{lstlisting}[
    label=listing:devise_new_user_class,
    caption=Configurando a nova classe de usuário para o Devise,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
devise_for :users, class_name: 'OtherUserClass',
    controllers: {sessions: 'users/sessions',
                  registrations: 'users/registrations',
                  passwords: 'users/passwords'}
\end{lstlisting}

\subsection{Configuração das migrations}

A classe de usuário fornece como padrão os atributos nome de usuário, e-mail e senha. Para adicionar ou remover atributos para esta ou qualquer outra classe pode-se adicionar a \textit{migrate} na aplicação. O SocialFramework dispõe de um gerador para fazer isso, neste caso só é necessário executar:

\begin{lstlisting}[
    label=listing:generate_migrate,
    caption=Geração das migrations,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:install_migrations -m users
\end{lstlisting}

A \textit{migrate} de usuário será adicionada na aplicação e poderá ser alterada. O parâmetro `m' é usado para gerar \textit{migrations} específicas, o \textit{script} espera os nomes das \textit{migrations}. Caso não exista a migration na aplicação, esta será gerada.

Caso seja adicionado ou removido um atributo para o usuário deve-se notificar o Devise, usando um filtro \textit{before} na ``ApplicationController'':

\begin{lstlisting}[
    label=listing:user_attribute,
    caption=Configuração para adicionar um novo atributo de usuário,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.for(:sign_up) << :new_attribute
    devise_parameter_sanitizer.for(:account_update) << :new_attribute
  end
end
\end{lstlisting}

Isto faz com que o \textit{sign\_up} e o \textit{account\_update} receba o novo atributo. Pode-se usar o método de remoção para remover os atributos existentes. Para adiconar ou remover o parâmetor em outras ações, por exemplo o \textit{sign\_in}, deve-se fazer o mesmo procedimento.

\subsection{Configuração das controllers}

Todas as \textit{controllers} do Devise podem ser extendidas e ter o seus métodos sobrescritos. Por exemplo:

\begin{lstlisting}[
    label=listing:extensao_controller,
    caption=Extensão de uma controller,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
class OtherRegistrationControllerClass < Users::RegistrationsController
  # Your code goes here
end
\end{lstlisting}

Outras \textit{controllers} são: ``confirmations'', ``omniauth\_callbacks'', ``passwords'', ``sessions'' e ``unlocks''. Para usar os módulos de ``omniauth\_callbacks'', ``unlocks'' e ``confirmations'' é necessário adicionar esses respectivos módulos do Devise na aplicação. Todas as \textit{controllers} do Devise no SocialFramework possuem o prefixo ``Users''.

\subsection{Configuração das rotas}

Quando se substitui algumas \textit{controllers} do Devise deve-se definir essas novas \textit{controllers} nas rotas. Isto pode ser feito alterando o caminho para a \textit{controller} na configuração \textit{devise\_for}, como no exemplo a seguir:

\begin{lstlisting}[
    label=listing:configuracao_controller,
    caption=Configuração de uma controller,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
devise_for :users, class_name: 'SocialFramework::User',
  controllers: {sessions: 'users/sessions',
                registrations: 'new_registration_controller_path',
                passwords: 'users/passwords'}
\end{lstlisting}

A \textit{controller} de registro foi extendida e a nova \textit{controller} foi adicionada nas configurações de rotas do Devise.

\subsection{Configuração das views}

Para adicionar as \textit{views} do Devise na aplicação o SocialFramework um gerador para executar esta tarefa, para executa-lo deve-se usar o seguinte comando:

\begin{lstlisting}[
    label=listing:gerar_views,
    caption=Geração das views,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:views
\end{lstlisting}

Para adicionar uma \textit{view} específica deve-se usar o parâmetro `-v' e passar o nome das \textit{views}, como no exemplo a seguir:

\begin{lstlisting}[
    label=listing:gerar_views,
    caption=Geração das views,
    numbers=none,
    language=Bash,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
$ rails generate social_framework:views -v registrations sessions passwords
\end{lstlisting}

Este comando irá adicionar as \textit{views} ``registrations'', ``sessions'' e ``passwords'' na aplicação. As outras \textit{views} são: ``confirmations'', ``mailer'' and ``unlocks''. Inicialmente, o SocialFramework adiciona as \textit{views} registrations e sessions na aplicação fornecendo autenticação e registro para os usuários.

\subsection{Módulos do SocialFramework}

Atualmente o SocialFramework possui os módulos de usuário, de rotas e de agendas.

\subsubsection{Módulo de usuários}

Este módulo fornece a lógica principal à redes sociais, como criar, confirmar e remover relacionamentos entre os usuários, além de buscas, registros, atualizações e autenticações.

A estrutura de relacionamentos foi construída com um relacionamento de muitos para muitos entre usuários através de arestas. As aresta possuem o usuário de origem, o usuário de destino, o \textit{status}, pode estar ativo ou inativo, se é bidirecional ou não, que  especifica relacionamentos como bidirecional ou unidirecional, e um rótulo com o nome do relacionamento. Pode-se existir múltiplas relações entre os mesmos usuários. Cada relacionamento é representar com uma aresta.

Para criar um novo relacionamento entre dois usuários deve-se utilizar o método `create\_relationship' definido na classe de usuário. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:create_relationship,
    caption=Método para criar relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
create_relationship(destiny, label, bidirectional=true, active=false)
\end{lstlisting}

O usuário que pede o relacionamento deve chamar este método e passar o usuário de destino e rótulo para o relacionamento. Por padrão é criada um relacionamento bidirecional e inativa entre esse usuários. É possível mudar esse comportamento passando os outros parâmetros para o método.

Para ativar o relacionamento criado é necessário uma confirmaçaõ. Para confirmar de usuário de destino deve invocar o método `confirm\_relationship'. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:confirm_relationship,
    caption=Método para confirmar relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
confirm_relationship(user, label)
\end{lstlisting}

É necessário passar como parâmetro o usuário de origem e o rótulo com o tipo de relacionamento. O único usuário que pode confirmar o relacionamento é o usuário de destino.

Para remover algum relacionamento, os usuários devem chamar o método `remove\_relationship', passando o outro usuário no relacionamento e o rótulo do relacionamento. Esse método possui a seguinte assinatura:

\begin{lstlisting}[
    label=listing:remove_relationship,
    caption=Método para remover relacionamento,
    numbers=none,
    language=Ruby,
    basicstyle=\footnotesize\sffamily,
    keywordstyle=\color{red},
    stringstyle=\color{blue},
    showspaces=false,
    showstringspaces=false,
]
remove_relationship(destiny, label)
\end{lstlisting}

\subsubsection{Módulo de agendas}

\subsubsection{Módulo de rotas}

\section{Hotspots}

\section{Relatório de testes}

\section{Relatório de qualidade}

\section{Relatório de desempenho}

% \subsecton{Tempo de execução}

% \subsecton{Memória}

\section{Uso da rede social}
