\begin{apendicesenv}

\partapendices

\chapter{Grafos}

\section{Um Pouco mais de História}

Graças à resolução dada por Euler, mais tarde muitos outros problemas importantes, para o desenvolvimento da Matemática Aplicada, foram possíveis de serem modelados. Um desses modelos são as relações de amizade, de hierarquia, de trabalho. Netto \cite{Netto:2012}, aponta grafos como um auxílio para o estudo de problemas envolvendo inter-relacionamento de elementos (em química orgânica, eletricidade, organização, transporte, psicossociologia). Na verdade, grafos modelam diversas situações e muitas delas não quantificáveis.

Conforme Ore \cite{Ore:1963}, o matemático irlandês William Hamilton, em 1859, inventou um jogo chamado ``\textit{The Icosian Game}'', com um peculiar enigma envolvendo um dodecaedro, em que cada um dos 20 vértices foram nomeados com nomes de cidades importantes. O objetivo do jogo era, utilizando as 30 arestas do dodecaedro, passar por cada uma das cidades apenas uma vez, começando e terminando na mesma cidade. Um exemplo do grafo pode ser visualizado na figura \ref{grafo_hamiltoniano}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.3]{figuras/referencial_teorico/grafo_hamiltoniano.eps}
	\caption[Grafo hamiltoniano]{Grafo hamiltoniano \cite{Ore:1963}}
	\label{grafo_hamiltoniano}
\end{figure}

Apesar da simples formulação, o problema admite muitos caminhos como resposta. No problema de Hamilton, temos uma diferença significativa em relação ao problema de Euler. Encontrar um caminho euleriano significa encontrar um caminho que passe por todas as arestas do grafo uma única vez, podendo ser aberto ou fechado. Nos caminhos hamiltonianos, cada vértice é visitado uma única vez. O problema fica mais complexo com tal condição \cite{Costa:2011}.

\section{Outras Definições}

Um grafo é finito se tanto o seu conjunto de vértices, quanto o seu conjunto de arestas são finitos. Um grafo sem vértices (e, portanto, sem arestas) é o grafo nulo. Qualquer grafo apenas com um vértice é referido como trivial. Todos os outros grafos são não-triviais \cite{Costa:2011}.

Um grafo é simples se não tem \textit{loops} ou arestas paralelas \cite{Diestel:1997}, como exemplificado na figura \ref{grafo_simples}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.2]{figuras/referencial_teorico/grafo_simples.eps}
	\caption[Exemplo de grafo simples]{Exemplo de grafo simples \cite{Costa:2011}}
	\label{grafo_simples}
\end{figure}

Certos tipos de grafos podem desempenhar papéis proeminentes na teoria dos grafos. Um grafo conexo é um grafo simples no qual quaisquer dois vértices são ligados por um caminho. Um grafo é vazio quando não há dois vértices adjacentes (isto é, o conjunto de arestas é vazio). Um grafo é bipartido se o seu conjunto de vértices pode ser particionado em dois subconjuntos \textit{X} e \textit{Y} para que cada aresta tem um fim em \textit{X} e um fim em \textit{Y}; uma tal partição (\textit{X}, \textit{Y}) é chamada uma bipartição do grafo, e \textit{X} e \textit{Y} suas partes. Pode-se denotar um grafo bipartido \textit{G} com bipartição (\textit{X}, \textit{Y}) por \textit{G}[\textit{X}, \textit{Y}]. Se \textit{G}[\textit{X}, \textit{Y}] é simples e todos os vértices de \textit{X} estão associados a cada vértice em \textit{Y}, então \textit{G} é chamado de um grafo bipartido completo. Uma estrela é um grafo bipartido completo \textit{G}[\textit{X}, \textit{Y}] com |\textit{X}| = 1 ou |\textit{Y}| = 1 \cite{Diestel:1997}.  A figura \ref{tipos_grafos} ilustra estes tipos de grafos, sendo o grafo ``A'' é um grafo conexo, o grafo ``B'' é um grafo vazio e o grafo ``C'' é um grafo bipartido completo.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.4]{figuras/referencial_teorico/tipos_grafos.eps}
	\caption[Tipos de grafos]{Tipos de grafos \cite{Diestel:1997}}
	\label{tipos_grafos}
\end{figure}

Um caminho é um grafo simples cujos vértices podem ser dispostos em uma sequência linear. De tal forma que dois vértices são adjacentes se forem consecutivos na sequência, e não adjacentes caso não forem consecutivos \cite{Bondy:2007}. Dessa forma, diz-se que um vértice é alcançável a partir de outro, se houver um caminho levando o primeiro vértice ao último \cite{Costa:2011}. A figura \ref{caminho} apresenta um caminho (arestas em vermelho) do vértice ``a'' até o vértice ``e''.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{figuras/referencial_teorico/caminho.eps}
	\caption[Caminho]{Caminho \cite{Costa:2011}}
	\label{caminho}
\end{figure}

Do mesmo modo, um ciclo é um grafo simples cujos vértices podem ser dispostos em uma sequência cíclica de tal maneira que dois vértices são adjacentes se forem consecutivos na sequência. O comprimento de um caminho ou de um ciclo é o número de suas arestas \cite{Costa:2011}. É possível observar na figura \ref{ciclos} alguns exemplos de grafos com ciclo.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.3]{figuras/referencial_teorico/ciclos.eps}
	\caption[Exemplo de grafos com ciclos]{Exemplo de grafos com ciclos \cite{Costa:2011}}
	\label{ciclos}
\end{figure}

Um grafo é conectado se, para cada partição de seus vértices definido em dois conjuntos \textit{X} e \textit{Y} não vazios, existe uma aresta com uma extremidade em \textit{X} e uma extremidade em \textit{Y}; caso contrário, o grafo é desconectado. Em outras palavras, um grafo é desconectado se o conjunto de vértices pode ser particionado em dois subconjuntos não vazios \textit{X} e \textit{Y} e que nenhuma aresta tem uma extremidade em \textit{X} e a outra extremidade em \textit{Y}. É instrutivo comparar esta definição com a de um grafo bipartido. Os exemplos de grafos conectados e desconectados são apresentados na figura \ref{desconectados}, onde o grafo ``X'' e o grafo ``Y'' são dois grafos distintos conectados. Porém se fossem trados como um único grafo, este seria um grafo desconectado \cite{Bondy:2007}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.45]{figuras/referencial_teorico/desconectados.eps}
	\caption[Exemplo de grafos conectados e desconectados]{Exemplo de grafos conectados e desconectados \cite{Bondy:2007}}
	\label{desconectados}
\end{figure}

O grau de um vértice \textit{v} em um grafo \textit{G}, designado por \textit{d$_G$}(\textit{v}), é o número de arestas de \textit{G} que incidem em \textit{v}; para cada \textit{loop} é contado duas arestas. Em particular, se \textit{G} é um grafo simples, \textit{d$_G$}(\textit{v}) é o número de vizinhos de \textit{v} em \textit{G}. Um vértice de grau zero é chamado um vértice isolado. Denominamos por $\delta$(\textit{G}) e $\Delta$(\textit{G}) mínimo e máximo graus dos vértices de \textit{G}, e por \textit{d}(\textit{G}), o seu grau médio, $\frac{1}{n}\sum_{\textit{v}\in\textit{V}} \textit{d}(\textit{v})$ \cite{Diestel:1997}.

\chapter{Algoritmos}

\section{Busca em Grafos}

A busca em grafos refere-se ao método de explorar o grafo, ou seja, obter um método sistemático para percorrer seus vértices e arestas. Para isto, há dois principais algoritmos, busca em profundidade (\textit{DFS - Depth First Search}) e busca em largura (\textit{BFS - Breadth First Search}). Em ambos os casos parte-se de um vértice qualquer.

\subsection{DFS}
\label{subsec:dfs}

A ideia por trás do \textit{DFS} é alcançar ``mais fundo'' no grafo quanto possível. A ordem em que os vértices são visitados depende da ordem em que os vizinhos de cada vértice aparecem na lista de adjacência \cite{Cormen:2001}. A seguir é exemplificado um fluxo do funcionamento do DFS.

Considere as Figuras a seguir para a exemplificação do DFS.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs1.eps}
	\caption[Exemplo DFS etapa 1]{Exemplo DFS etapa 1 \cite{Cormen:2001}}
	\label{dfs1}
\end{figure}

A busca irá partir do vértice arbitrário \textit{v}, chamado de vértice raiz. A partir do vértice raiz é possível percorrer três arestas: (\textit{v}, \textit{a}), (\textit{v}, \textit{b}) e (\textit{v}, \textit{c}). A aresta a ser seguida será (\textit{v}, \textit{a}).

\newpage

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs2.eps}
	\caption[Exemplo DFS etapa 2]{Exemplo DFS etapa 2 \cite{Cormen:2001}}
	\label{dfs2}
\end{figure}

O vértice \textit{a} possui três arestas, que são: (\textit{a}, \textit{v}), (\textit{a}, \textit{b}) e (\textit{a}, \textit{d}). Como o vértice \textit{v} já foi visitado, a aresta a ser seguida será (\textit{a}, \textit{b}).

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs3.eps}
	\caption[Exemplo DFS etapa 3]{Exemplo DFS etapa 3 \cite{Cormen:2001}}
	\label{dfs3}
\end{figure}

A partir de \textit{b}, é possível escolher as seguintes arestas: (\textit{b}, \textit{v}), (\textit{b}, \textit{a}) e (\textit{b}, \textit{c}). Porém como os vértices \textit{v} e \textit{a} já foram visitados, a opção restante será a aresta (\textit{b}, \textit{c}).

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs4.eps}
	\caption[Exemplo DFS etapa 4]{Exemplo DFS etapa 4 \cite{Cormen:2001}}
	\label{dfs4}
\end{figure}

Ao alcançar \textit{c}, há duas possibilidades: (\textit{c}, \textit{v}) e (\textit{c}, \textit{b}). Porém ambos os vértices \textit{v} e \textit{b} já são conhecidos. Neste caso não há para onde se aprofundar. Entretanto, ainda existem vértices não descobertos. Nesse caso, deve-se voltar até o vértice \textit{b}, verificando se há alguma aresta que leva a um vértice ainda não visitado. Caso ocorra tal situação, deve-se voltar novamente pelo caminho percorrido, chegando ao vértice \textit{a}. Em \textit{a}, a aresta (\textit{a}, \textit{d}) leva a um vértice ainda não descoberto, portanto, esse caminho deve ser tomado.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs5.eps}
	\caption[Exemplo DFS etapa 5]{Exemplo DFS etapa 5 \cite{Cormen:2001}}
	\label{dfs5}
\end{figure}

Em \textit{d}, há dois caminhos a seguir: (\textit{d}, \textit{a}) e (\textit{d}, \textit{e}). Porém a única aresta que leva a um vértice não visitado é (\textit{d}, \textit{e}). Esta deverá ser seguida.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs6.eps}
	\caption[Exemplo DFS etapa 6]{Exemplo DFS etapa 6 \cite{Cormen:2001}}
	\label{dfs6}
\end{figure}

Ao alcançar o vértice \textit{e}, não existem vértices não visitados, mesmo na volta no caminho. Portanto, o percurso realizado pelo \textit{DFS} pode ser observado na figura \ref{dfs_percurso}, o qual é uma árvore.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.25]{figuras/referencial_teorico/dfs/dfs_percurso.eps}
	\caption[Percurso do DFS]{Percurso do DFS \cite{Cormen:2001}}
	\label{dfs_percurso}
\end{figure}

\subsection{BFS}
\label{subsec:bfs}

O \textit{DFS}, a partir de um vértice \textit{v}, tenta visitar algum vizinho deste, em seguida, um vizinho deste vizinho, e assim por diante. O \textit{BFS}, a partir de um vértice \textit{v}, visita todos os vizinhos de \textit{v}. Quando visitado todos os vizinhos de um vértice, os vizinhos destes vizinhos serão visitados \cite{Brassard:1988}.

A Figura \ref{bfs} exemplifica o algoritmo da busca \textit{BFS}, onde as letras significam o estado da busca e a ordem de cada estado. Os vértices marcados como vermelho representam que estes já foram visitados; os vértices marcados como azul representam que estes vértices serão os próximos a serem visitados.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.55]{figuras/referencial_teorico/bfs.eps}
	\caption[Percurso do BFS]{Percurso do BFS \cite{Brassard:1988}}
	\label{bfs}
\end{figure}

\chapter{Reutilização de Software}
\label{chapter:reutilizacao_software}

\section{Serviços}
\label{sec:servicos}

De uma maneira geral, serviços são atividades providas e realizadas por uma máquina ou um humano. No desenvolvimento de software, serviços são considerados um bloco de construção reutilizável que oferece uma funcionalidade particular. A noção de reusabilidade apresentada lembra a reutilização antes comentada no conceito de componentes. De fato, essas duas abordagens estão próximas, pois representam uma ideia de desenvolvimento comum, onde blocos de software são construídos para serem usados por atores diferentes e em outros locais \cite{Stojanovic:Dahanayake:2005}.

Com o advento dos serviços, surgiu um novo termo, a ``Orientação a serviços''. Essa ocorre quando alguns processos são modelados e construídos como unidades bem definidas e formam serviços. Esses são encapsulados em componentes de software para serem usados por outras aplicações, conferindo a ideia de um sistema provedor (o sistema que provê o serviço) e um sistema consumidor (que consome os serviços prestados) \cite{Victorino:Brascher:2009}.

Se todas as aplicações usassem a mesma interface de programação e o mesmo protocolo de interoperabilidade, todo trabalho de software seria mais simples. Essa é a premissa que trouxe o desenvolvimento orientado a serviços para o mundo da tecnologia da informação. Quando se desenvolve dessa forma, os serviços tornam-se a base para a criação de novas estratégias de solução \cite{Newcomer:Lomow:2004}.

Apesar das abordagens de orientação a serviços e orientação a componentes serem bem similares, no livro \cite{Stojanovic:Dahanayake:2005}, são apresentadas algumas diferenças entre as mesmas, que são:

\begin{itemize}
	\item o tempo de integração. Na orientação baseada em componentes, a integração com a aplicação desenvolvida ocorre no momento da construção; enquanto, na orientação a serviços, a integração pode ocorrer antes ou durante a execução, pois apenas as descrições dos serviços estão disponíveis no momento da execução;
	\item nos serviços, o foco é a descoberta, existindo uma ênfase mais forte na separação entre a descrição do serviço e a implementação. Nos componentes, é a composição, onde as partes são integradas diretamente na aplicação;
	\item serviços são mais voltados para tarefas dinâmicas, ao contrário dos componentes que são mais voltados para pontos estáticos. Porém, esse comportamento dinânmico pode ser feito também em componentes, e;
	\item a orientação a componentes atribui maior responsabilidade para o ambiente e a execução da própria aplicação. Os serviços não são necessariamente dessa forma, pois podem estar presentes em outras máquinas e outros servidores externos.
\end{itemize}

A seguir serão apresentadas duas formas conhecidas e já consolidadas de implementações de serviços, os \textit{Web Services} e os \textit{Serviços RESTful}.

\subsection{Web Services}

Os serviços são informatizados por tecnologias interoperáveis, que são capazes de se comunicar entre si, e isso independe da plataforma e da linguagem de programação utilizadas. Dentre essas tecnologias, os ``\textit{Web Services}'' (serviços web) se destacam. Esses serviços fornecem um modo padronizado de integrar aplicativos web, e assim, organizações podem se comunicar sem que uma tenha conhecimento abrangente dos sistemas da outra \cite{Victorino:Brascher:2009}.

Um ``\textit{Web Service}'' é uma noção abstrata que deve ser implementada por um agente concreto, sendo esse agente um pedaço de software que envia e recebe mensagens. O serviço é o recurso caracterizado pela funcionalidade abstrata que é servida.

O XML hoje é amplamente utilizado quase como o protocolo HTTP, e faz parte da solução para aplicação de ``\textit{Web Services}''. Normalmente, usado para realizar a formatação dos dados \cite{Alonso:Casati:Kuno:Machiraju:2010}.

Simplificando, os ``\textit{Web Services}'' possuem três características e tecnologias principais que são usadas para desenvolvê-los: o XML, que é a especificação sobre a qual estes são construídos; o WSDL, que provê as interfaces fundamentais que serão usadas, e SOAP, que é responsável pela comunicação com outros serviços. Pode-se dizer que um ``\textit{Web Service}'' deve fornecer interfaces de uso simples e se comunicar facilmente com outros serviços \cite{Newcomer:Lomow:2004}.

\subsection{Serviços RESTFul}

REST é um estilo arquitetural para sistemas hipermídia distribuídos, reunindo um grupo de critérios que serão incorporados ao projeto de aplicações distribuídas. Os Serviços RESTful são serviços web que seguem os critérios REST \cite{Filho:2009}.

O uso de serviços RESTFul permitiu grande impulso no desenvolvimento de aplicações distribuídas baseadas em padrões WEB tradicionais. Esses serviços são leves, práticos e fáceis de serem integrados em várias aplicações \cite{Rosenberg:Curbera:Duftler:Khalaf:2008}.

Os serviços da web estão a cada dia buscando soluções mais simples e mais leves para compor suas funcionalidades. Os serviços RESTFul introduzem um novo tipo de abstração que busca oferecer as funcionalidades já existentes dos serviços da \textit{web} comuns. Porém, de uma forma mais leve e simples \cite{Pautasso:2009}.

De acordo com \cite{Filho:2009}, os serviços RESTFul possuem cinco conceitos importantes, que são descritos a seguir:

\begin{itemize}
	\item \textbf{recurso:} é uma abstração ou conceito relevante para o domínio tratado. Os recursos podem ser concretos ou abstratos, e têm-se maior flexibilidade para definição dos mesmos. Um serviço pode ter mais de um recurso sem afetar a sua qualidade;
	\item \textbf{representação:} é a representação de um recurso, apresentando informações sobre o mesmo. Dependendo do serviço e do nível de abstração, são mostradas mais ou menos informações dos recursos. A representação é uma serialização do recurso em uma linguagem específica, as mais usadas são: XML, XHTML e JSON. Um serviço pode mostrar mais de um tipo de serialização de seus recursos, basta que as requisições informem qual o formato desejado que o serviço irá apresentar os dados na serialização correta;
	\item \textbf{identificador uniforme:} cada recurso deve ter ao menos um identificador para localização do mesmo. Se não existe um identificador uniforme, não se pode considerar que um objeto é um recurso. Pode-se ter ilimitados identificadores para um mesmo recurso.
	\item \textbf{interface unificada:} A interface unificada diz respeito a todos os serviços utilizarem o mesmo protocolo, no caso, o HTTP. Dessa forma, um cliente que conheça esse protocolo pode facilmente utilizar os métodos que são proporcionados por ele para fazer requisições nos serviços disponíveis, e;
	\item \textbf{escopo de execução:} neste caso, o serviço RESTFul também se utiliza do protocolo HTTP, porém, diz respeito aos parâmetros que devem ser enviados junto da requisição para que o serviço possa tratar o recurso corretamente. Pode ser, por exemplo, a identificação de um objeto em um conjunto de recursos.
\end{itemize}

\section{Padrão Abstract Factory}
\label{sec:padrao_abstract_factory}

A seguir, têm-se uma breve descrição do padrão ``\textit{Abstract Factory}'', como foi definido em \cite{Gamma:1995}.

Esse padrão fornece uma estrutura para criação de famílias de objetos relacionados sem a necessidade de definir suas classes concretas. A figura \ref{abstract_factory} apresenta o modelo do ``\textit{Abstract Factory}''.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{figuras/apendices/abstract_factory.eps}
	\caption[Modelo genérico do Abstract Factory]{Modelo genérico do Abstract Factory \cite{Gamma:1995}}
	\label{abstract_factory}
\end{figure}

O modelo da figura apresenta cinco tipos de classes. ``\textit{Abstract Factory}'', ``\textit{Concrete Factory}'', ``\textit{Abstract Product}'', ``\textit{Product}'' e ``\textit{Client}''.

\begin{itemize}
	\item \textbf{\textit{Abstract Factory:}} Faz declarações de interfaces para criação de quaisquer produtos;
	\item \textbf{\textit{Concrete Factory:}} Essas classes já estão focadas no tipo de produtos que vão criar e implementam os métodos abstratos para essa criação;
	\item \textbf{\textit{Abstract Product:}} Classes abstratas que declaram interfaces para um determinado tipo de produto que deverá ser criado;
	\item \textbf{\textit{Product:}} Classes que representam o próprio produto que deverá ser criado, são as classes que são chamadas pelos métodos de criação presentes nas ``\textit{Concrete Factory}'';
	\item \textbf{\textit{Client:}} É a classe que representa quem irá fazer as chamadas aos métodos de criação. Não é necessário que conheça de fato as classes concretas de produto, pois apenas faz uso das interfaces declaradas em ``\textit{Abstract Factory}'' e ``\textit{Abstract Product}''; a primeira para criar os produtos, e a segunda para usá-los.
\end{itemize}

Este padrão oferece algumas vantagens e desvantagens que são apresentadas a seguir:

\begin{itemize}
	\item \textbf{Isolamento de classes concretas:} O cliente pode trabalhar com as criações dos produtos sem necessariamente conhecer as classes concretas que existem por traz, pois este trabalha apenas com as interfaces abstratas providas.
	\item \textbf{Fácil troca de famílias de produtos:} Basta trocar qual é a classe concreta que deverá ser usada que todo o comportamento dos produtos irá se alterar de acordo com essa classe. Isso pode ser feito facilmente no momento de instanciação da fábrica.
	\item \textbf{Harmonia entre produtos:} Como o padrão permite aos clientes trabalharem apenas com uma família por vez, fica fácil alcançar harmonia, pois todos os produtos da família estão de alguma forma relacionados.
	\item \textbf{Suporte a novos tipos de produtos é difícil:} Como a interface do ``\textit{Abstract Factory}'', no início, cria uma quantidade fixa de produtos para serem implementados, alterar isso fica difícil, pois é necessário mexer na classe principal e criar as subclasses concernentes.
\end{itemize}

\section{Padrão Factory Method}
\label{sec:padrao_factory_method}

Um outro padrão de criação bem parecido com o \nameref{sec:padrao_abstract_factory}, porém, diferentemente do anterior que cria famílias de objetos, o \textit{Factory Method} é responsável por criar um único objeto \cite{Gamma:1995}. A figura \ref{factory_method} apresenta o modelo de classes desse padrão:

\newpage
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{figuras/apendices/factory_method.eps}
	\caption[Modelo genérico do Factory Method]{Modelo genérico do Factory Method \cite{Gamma:1995}}
	\label{factory_method}
\end{figure}

Com esse padrão fica fácil e prático fazer a alteração de uma sub-classe concreta, uma vez que, a aplicação passa a trabalhar com a interface de ``\textit{Product}'', o código pode trabalhar com quaisquer classes ``\textit{ConcrectProduct}'' definidas pelo usuário.

As classes mostradas no modelo são descritas a seguir:

\begin{itemize}
	\item \textbf{\textit{Product}}: Interface de objetos que o método de fábrica irá criar;
	\item \textbf{\textit{ConcretProduct}}: Implementação da interface ``\textit{Product}'';
	\item \textbf{\textit{Creator}}: Interface com método para criação de um ``\textit{Product}'';
	\item \textbf{\textit{ConcrectCreator}}: Implementação da interface ``\textit{Creator}'', reimplementa o método para criação de um ``\textit{ConcrectProduct}''.
\end{itemize}

\section{Padrão Strategy}
\label{sec:padrao_strategy}

O padrão ``\textit{Strategy}'' foi desenvolvido para auxiliar desenvolvedores a trabalhar com famílias de algoritmos que podem variar independentemente dos clientes que os usam \cite{Gamma:1995}. Com esse padrão é possível mudar facilmente o comportamento de um dado algoritmo apenas trocando a classe que é usada na implementação do mesmo. A seguir é apresentado o modelo de classes desse padrão na figura \ref{strategy}.

\newpage
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{figuras/apendices/strategy.eps}
	\caption[Modelo genérico do Strategy]{Modelo genérico do Strategy \cite{Gamma:1995}}
	\label{strategy}
\end{figure}

As classes do modelo são descritas a seguir.

\begin{itemize}
	\item \textbf{\textit{Strategy}}: Interface comum para todos os algoritmos que serão suportados.
	\item \textbf{\textit{ConcretStrategy}}: Implementação da interface ``\textit{Strategy}'' definindo cada método com um comportamento esperado para um determinado cliente;
	\item \textbf{\textit{Context}}: Essa classe faz uso da interface ``\textit{Strategy}'' chamando cada um de seus métodos através de um objeto ``\textit{ConcretStrategy}'' que é definido, sendo assim,  o comportamento esperado será retornado de acordo com o ``\textit{ConcretStrategy}'' que é passado.
\end{itemize}

\chapter{Metodologia}
\label{apend_chap:metodologia}

Metodologias específicas colaboram para estabelecer diretrizes e boas práticas na condução do trabalho, conferindo padronização, noções de pesquisa científica, dentre outras contribuições \cite{Wohlin:2000}.

A metodologia pode ser entendida como um conjunto de etapas a serem realizadas na condução do processo investigativo em um determinado contexto. É a metodologia que define os passos que serão seguidos para realização das pesquisas, escolha do tema, planejamento da investigação, desenvolvimento, coleta e análise dos dados, análise dos resultados e conclusões a respeito das lições aprendidas \cite{Moresi:2003}.

Pesquisar significa identificar uma dúvida que necessite ser esclarecida, construir e executar o processo que apresente a solução desta, quando não há teorias que a expliquem ou quando as teorias que existem não estão aptas para fazê-lo \cite{Koche:1997}. A seguir, serão apresentadas as formas de se classificar uma pesquisa.

\section{Classificação da pesquisa}

\begin{itemize}
	\item Do ponto de vista da natureza da pesquisa, esta pode ser:
		\begin{itemize}
			\item \textbf{Pesquisa Básica:} Possui o objetivo de gerar novos conhecimentos para a ciência. Neste tipo de pesquisa não é obrigatório que o conhecimento gere um uso prático \cite{Silva:Tafner:2007}.
			\item \textbf{Pesquisa Aplicada:} Visa gerar uma maior compreensão para assuntos práticos dirigidos à solução de problemas específicos \cite{Silva:Tafner:2007}.
		\end{itemize}

	\item Do ponto de vista da forma de abordagem do problema,tem-se:
		\begin{itemize}
			\item \textbf{Pesquisa Quantitativa:} O estudo quantitativo considera que tudo pode ser quantificável, ou seja, que os números podem ser classificados, gerando informações ao analisá-los, através da análise estatística \cite{Travassos:2002}.
			\item \textbf{Pesquisa Qualitativa:} O estudo qualitativo está relacionado à pesquisa sobre os objetos, quando os resultados são apresentados em termos naturais, usando conjuntos nebulosos, porcentagens de satisfação, dentre outras formas de classificar algo subjetivo \cite{Travassos:2002}.
		\end{itemize}

	\item Do ponto de vista de seus objetivos, tem-se:
		\begin{itemize}
			\item \textbf{Pesquisa Exploratória:} Esta pesquisa tem como objetivo proporcionar maior familiaridade com o problema, possibilitando o aprimoramento de ideias ou a descoberta de intuições \cite{Gil:2010}.
			\item \textbf{Pesquisa Descritiva:} Seu principal objetivo é a descrição das características de determinada população ou fenômeno ou, então, o estabelecimento de relações entre variáveis \cite{Gil:2010}.
			\item \textbf{Pesquisa Explicativa:} Tem como preocupação central identificar os fatores que determinam ou que contribuem para a ocorrência dos fenômenos. Esse é o tipo de pesquisa que mais aprofunda o conhecimento da realidade, porque explica a razão, o porquê das coisas \cite{Gil:2010}.
		\end{itemize}

	\item Do ponto de vista dos procedimentos técnicos, pode ser:
		\begin{itemize}
			\item \textbf{Pesquisa Bibliográfica:} Visa encontrar as fontes primárias e secundárias e os materiais científicos e tecnológicos necessários para a realização do trabalho científico ou técnico-científico. Muitos estudos fazem uso do levantamento bibliográfico ou são desenvolvidas exclusivamente por fontes bibliográficas. Sua principal vantagem é possibilitar ao investigador a cobertura de uma gama de acontecimentos muito ampla \cite{Silva:Tafner:2007}.

			\item \textbf{Pesquisa Documental:} Assemelha-se à pesquisa bibliográfica. Porém, esta é realizada a partir de materiais que não receberam tratamento analítico. Por exemplo, reportagens de jornal, cartas, contratos, diários, filmes, fotografias e gravações. A pesquisa documental pode ser realizada ainda através de documentos de segunda mão, que de alguma forma já foram analisados. Por exemplo, relatórios de empresas e tabelas estatísticas \cite{Gil:2010}.

			\item \textbf{Levantamento:} É uma investigação realizada em retrospecto, que em seguida, mediante análise quantitativa, chega às conclusões correspondentes aos dados coletados. O levantamento feito com informações de todos os integrantes do universo da pesquisa origina um censo. \cite{Mafra:Travassos:2006}.
			
			\item \textbf{Estudo de Caso:} São estudos conduzidos com o propósito de se investigar uma entidade ou um fenômeno dentro de um espaço de tempo específico. Estes são usados principalmente para a monitoração de atributos presentes em projetos, atividades ou atribuições. Durante a sua condução, dados são coletados e analisados estatisticamente de forma a permitir a avaliação de um determinado atributo ou do relacionamento entre diferentes atributos. \cite{Mafra:Travassos:2006}
			
			\item \textbf{Pesquisa-Ação:} É realizada em conjunto com uma ação ou com a resolução de um problema coletivo, visando definir o campo de investigação, as expectativas dos interessados e o tipo de auxílio que estes poderão exercer ao longo do processo de pesquisa. Esta pesquisa implica no contato direto com o campo de estudo, envolvendo o reconhecimento visual do local, consulta a documentos diversos e a discussão com os envolvidos na pesquisa. A abordagem dos problemas dos grupos investigados na pesquisa-ação é mais qualitativa do que quantitativa \cite{Silva:Tafner:2007}.
			
			\item \textbf{Pesquisa Participante:} A intenção é obter um maior conhecimento sobre o grupo. O grupo investigado tem ciência da finalidade, dos objetivos da pesquisa e da identidade do pesquisador. A pesquisa participante permite a observação das ações no próprio momento em que ocorrem \cite{Silva:Tafner:2007}.
			
			\item \textbf{Pesquisa Experimental:} É conduzida quando deseja-se obter um maior controle da situação, ao se manipular as variáveis envolvidas no estudo de forma direta, sistemática e precisa. A pesquisa experimental necessita de previsão de relações entre as variáveis a serem estudadas, como também o seu controle. O objetivo é manipular uma ou mais variáveis e controlar todas as outras variáveis em um valor fixo. O efeito da manipulação das variáveis é então medido e, baseado nessa medição, análises estatísticas são conduzidas. A condução de experimentos reais é rara em Engenharia de Software, devido à dificuldade de se alocar os participantes do estudo a diferentes tratamentos de forma aleatória. Nessas situações, tais estudos denominam-se quasi-experimentos \cite{Mafra:Travassos:2006}.
			
			\item \textbf{Pesquisa Ex-Post-Facto:} Realizada quando o experimento se dá depois dos fatos. Neste caso, o pesquisador não tem controle sobre as variáveis. Esta pesquisa difere da pesquisa experimental pelo fato de o fenômeno ocorrer naturalmente sem que o pesquisador tenha controle sobre ele, ou seja, o pesquisador passa a ser um mero observador do acontecimento \cite{Silva:Tafner:2007}.
		\end{itemize}

\end{itemize}

\chapter{Prova de Conceito}
\label{chap:prova_conceito}

Foi desenvolvida uma pequena aplicação para implementação de alguns conceitos discutidos neste trabalho.

De modo geral, a aplicação desenvolvida implementa uma rede de usuários ligados entre si, formando um grafo. A solução contêm as classes \textit{User}, \textit{Edge} e \textit{Graph}. A classe \textit{Edge} é usada para fazer as ligações entre as entidades. A classe \textit{Graph} representa a própria rede com todos os usuários. A classe de \textit{User} pode ser vista como os vértices do grafo. Foram implementadas as funcionalidades de relacionamento descritas nas figuras \ref{segue} e \ref{amigo}, além de uma varredura dos usuários presentes no grafo pelos algoritmos de busca ~\nameref{subsec:bfs}, \textit{Breadth-First Search}, e ~\nameref{subsec:dfs}, \textit{Depth-First Search}.

A Figura \ref{modelo prova de conceito} apresenta o modelo das classes desenvolvidas na aplicação de prova de conceito e seus respectivos relacionamentos.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.8]{figuras/proposta/classes_prova_conceito.eps}
	\caption{Classes da prova de conceito}
	\label{modelo prova de conceito}
\end{figure}

Fica exemplificado o relacionamento entre as classes \textit{Graph} e \textit{User} na forma de uma composição, que indica que um usuário não pode existir sem estar presente na rede. O relacionamento entre usuários, como pode ser visto na Figura \ref{modelo prova de conceito}, é feito através das arestas que possuem: (i) um atributo \textit{origin}, que representa de qual usuário parte o relacionamento e (ii) um atributo \textit{destiny}, que representa a qual usuário é indicado o relacionamento criado. Cada aresta possui ainda uma lista de \textit{labels} que representam os nomes dos relacionamentos entre os usuários.

Pode-se ver ainda na Figura \ref{modelo prova de conceito} a apresentação dos métodos construídos. A classe \textit{User} possui os métodos responsáveis por estabelecer os relacionamentos entre usuários, conforme apresentado nas figuras \ref{segue} e \ref{amigo}. O método \textit{``follow\_user''} é responsável por criar um relacionamento unidirecional, que representa seguir um usuário. O método \textit{``add\_friend''} é responsável por relacionamentos bidirecionais. Este último, por sua vez, necessita ainda ser complementado pelo método \textit{``confirm\_friend''}, pois, ao se invocar o método \textit{``add\_friend''} cria-se uma aresta que possui o \textit{label} amigo e pendente, o que indica que o relacionamento ainda não está completo. Ao se invocar o método \textit{``confirm\_friend''}, outra aresta é criada no outro sentido e o \textit{label} pendente é removido, completando-se assim, o relacionamento entre os dois usuários.

A classe \textit{Graph} possui o método \textit{``add\_user''}, que é chamado sempre na criação de um novo usuário, visando adicionar este a rede. O método \textit{``set\_white''} tem como objetivo definir a cor de todos os usuários no grafo para branco. Esse atributo é usado ao se trabalhar com os recursos de buscas no grafo. Colorir o nó com a cor branca significa que este ainda não foi visitado. O método \textit{``dfs''} implementa o algoritmo de busca ~\nameref{subsec:dfs} e faz uma varredura no grafo. O mesmo acontece para o método \textit{``bfs''} que implementa a varredura de acordo com o algoritmo ~\nameref{subsec:bfs}. Os métodos \textit{``dfs\_visit''} e \textit{``bfs\_visit''} são métodos auxiliares que visitam o nó corrente e definem o próximo nó que será visitado de acordo com as regras definidas nos algoritmos.

A abordagem de lista de adjacência foi utilizada na implementação do grafo. Como as arestas trabalhadas possuem outras informações além da representação das ligações entre os nós, essa abordagem ocupa menos espaço em memória. Isso ocorre pois não existe representação de arestas que não estejam presentes no grafo. Além da redução da memória gasta, o tempo gasto para listar todos os nós que fazem ligação a um outro nó é reduzido, quando se usa lista de adjacência, pois basta realizar a leitura da lista para se obter essas informações. Já na matriz de adjacência e incidência, é necessário realizar uma busca em uma linha da matriz para verificar todas as ligações que um nó possui. O código fonte dessa aplicação pode ser encontrado em \url{https://github.com/TCC-SocialNetwork/concept-test}.

\chapter{Sprints}
\label{chap:sprints}

Neste capítulo serão apresentadas todas as estórias de usuário que foram definidas e desenvolvidas ao longo da contrução do SocialFramework e SocialBike. O período de desenvolvimento compreende as datas de 07/03/2016 a 21/06/2016. Durante esse período foram estabelecidas oito \textit{sprints} com duas semanas cada uma, com exceção da última que ficou com apenas uma semana.

A seguir serão apresentadas tabelas com as respectivas estórias, pontução e status. Pode-se verificar que todas as estórias estão completas e foram desenvolvidas para os sistemas propostos.

\begin{table}[]
\centering
\caption{Sprint 1 - Período de 07/03 a 19/03}
\label{sprint_1}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
1 & Como desenvolvedor gostaria de fornecer cadastro de usuários para ser usado em aplicações que utilizem o framework. & 3 & Completa \\

2 & Como desenvolvedor gostaria de fornecer autenticação de usuários para ser usada em aplicações que utilizem o framework. & 5 & Completa \\

3 & Como desenvolvedor gostaria de fornecer funcionalidades para relacionamento entre usuários para ser usada em aplicações que utilizem o framework. & 13 & Completa \\

4 & Como desenvolvedor gostaria que o framework monte uma rede com os usuários cadastrados apresentando todos os relacionamentos e vínculos entre os mesmos para facilitar consultas. & 13 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 2 - Período de 20/03 a 03/03}
\label{sprint_2}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
5 & Como desenvolvedor gostaria de fornecer pesquisas para encontrar algum elemento presente na rede social. & 13 & Completa \\

6 & O framework deve ser capaz de sugerir amigos a um usuário para que este possa aumentar sua rede de relacionamentos. & 13 & Completa \\

8 & Como desenvolvedor gostaria que o framework forneça scripts que auxiliem no uso do mesmo para suporte nas configurações e gerações de arquivos de acordo com um template definido. & 5 & Completa \\

9 & Como desenvolvedor gostaria de fornecer um script que gere as Views de usuários para acesso das suas funcionalidades. & 3 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 3 - Período de 20/03 a 17/04}
\label{sprint_3}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
7 & Como desenvolvedor gostaria que o Framework possibilite ao usuário a adição ou remoção de atributos das classes de modelo para mudar conforme as suas necessidades. & 8 & Completa \\

12 & Como desenvolvedor gostaria que o framework possibilite, na montagem do grafo, passar quais serão os atributos que os vértices terão para facilitar em pesquisas futuras. & 3 & Completa \\

13 & Como desenvolvedor gostaria que o framework possibilite a continuação de pesquisas no Grafo mesmo após ter retornado a quantidade padrão de resultados para visualização de mais resultados. & 13 & Completa \\

14 & Como desenvolvedor gostaria de fazer algumas refatorações para garantir a integridade do Módulo de Usuários. & 3 & Completa \\

21 & Como desenvolvedor gostaria que o Framework possibilite a definição de um período para buscar o melhor horário para marcação de um evento entre um conjunto de usuários. & 8 & Completa \\ \bottomrule

\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 4 - Período de 18/04 a 01/05}
\label{sprint_4}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
10 & Como desenvolvedor gostaria de fornecer uma documentação do framework para facilitar o uso do mesmo. & 3 & Completa \\

11 & BUG: Como desenvolvedor gostaria de especificar relacionamentos como unidirecionais ou bidirecionais para detalhar melhor. & 5 & Completa \\

15 & Como desenvolvedor gostaria que o Framework possibilite a qualquer usuário checar a sua disponibilidade antes de aceitar participar ou não de um evento para maior controle. & 3 & Completa \\

16 & Como desenvolvedor gostaria que o Framework possibilite tornar membros como ``Administradores'' em um evento para que possam gerenciar e/ou convidar mais pessoas para o evento em questão. & 3 & Completa \\

18 & Como desenvolvedor gostaria que o Framework possibilite verificar o horário que contemple o maior peso de um conjunto de usuários para marcação de um evento. & 20 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 5 - Período de 02/05 a 15/05}
\label{sprint_5}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
17 & Como desenvolvedor gostaria que o Framework possibilite convidar qualquer um dos meus relacionamentos para um determinado evento para um melhor controle. & 3 & Completa \\

19 & Como desenvolvedor gostaria que o Framework possibilite definir usuários `Fixos' em um evento que deverá ser marcado para garantir que esses usuários poderão estar presentes. & 13 & Completa \\

20 & Como desenvolvedor gostaria que o Framework possibilite a definição de um peso para os usuários para auxiliar no casamento de horários buscando o maior peso. & 3 & Completa \\

24 & Como desenvolvedor gostaria que o Framework possibilite aos usuários a criação de agendas para um maior controle de suas participações em qualquer evento. & 1 & Completa \\

25 & Como desenvolvedor gostaria que o Framework realizasse pesquisa em eventos levando em consideração os usuários presentes na rede de um usuário para aumentar os elementos das pesquisas. & 8 & Completa \\

26 & Como desenvolvedor gostaria que o Framework possibilite a qualquer usuário participar de um evento público para facilitar a divulgação do mesmo. & 2 & Completa \\

27 & Como desenvolvedor gostaria que o Framework possibilite ao usuário criador de um evento remover o mesmo para cancelamento. & 2 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 6 - Período de 16/05 a 29/05}
\label{sprint_6}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
22 & Como desenvolvedor gostaria que o Framework possibilite a criação de eventos definindo a data, hora e duração quando for o caso para anunciar o mesmo a outros usuários. & 8 & Completa \\ 

28 & Como desenvolvedor gostaria que o Framework possibilite ao usuário Criador e aos Administradores de um evento remover convidados para manter um melhor controle. & 2 & Completa \\

29 & Como desenvolvedor gostaria de fornecer uma documentação do Módulo de Agenda para auxiliar no uso do mesmo. & 3 & Completa \\

30 & Como desenvolvedor gostaria que o Framework possa salvar rotas para os usuários para que possam comparar com outros. & 3 & Completa \\

32 & Como desenvolvedor gostaria que o Framework possibilite relacionar rotas com um evento para verificar os horários. & 5 & Completa \\

35 & Como desenvolvedor gostaria que o Framework verifique se duas rotas são compatíveis para sugerir aos usuários. & 5 & Completa \\

36 & Como desenvolvedor gostaria que o Framework sugira uma pequena alteração de rotas para se adequar a rotas de outros usuários. & 5 & Completa \\

37 & Como desenvolvedor gostaria de fornecer uma documentação do Módulo de Rotas para auxiliar no uso do mesmo. & 3 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 7 - Período de 30/05 a 12/06}
\label{sprint_7}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
34 & Como desenvolvedor gostaria que o Framework calcule a menor distância entre dois pontos dentro de um raio pré-definido para obter os pontos com a menor distância. & 8 & Completa \\

40 & BUG: Como desenvolvedor gostaria de ajustar retorno da pesquisa quando já está finalizada para que o retorno seje consistente. & 1 & Completa \\

41 & Como desenvolvedor gostaria de adicionar o Padrão Strategy para os helpers do framework para criar um ponto flexivel no framework. & 5 & Completa \\

42 & Como desenvolvedor gostaria de adicionar o padrão Abstract Factory para os Vértices e Arestas para criar um ponto flexivel no framework. & 3 & Completa \\

43 & Como desenvolvedor gostaria de colocar  os atributos para construção dos vértices no grafo no arquivo de inicialização do social framework. & 1 & Completa \\

45 & Como desenvolvedor gostaria de adicionar o padrão factory method para as classes de modelo para criar um ponto flexivel no framework. & 3 & Completa \\

46 & Como desenvolvedor gostaria de criar método em Evento que retorne os usuários confirmados ou não do evento para saber os usuários que realmente estão participando do evento. & 2 & Completa \\

47 & Como desenvolvedor gostaria de tornar método ``execute\_action?'' do evento público para que seja possível a sua utilização fora de sua classe. & 2 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[]
\centering
\caption{Sprint 8 - SocialBike - Período de 13/06 a 21/06}
\label{sprint_8}
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{@{}cp{10cm}cl@{}}
\toprule
\textbf{Id}  & \textbf{Estória} & \textbf{Pontos} & \textbf{Status} \\ \midrule
1 & Como usuário gostaria de me registrar para ter acesso a rede social. & 2 & Completa \\

2 & Como usuário gostaria de me relacionar com outros usuários rede para interagir com a minha rede de contatos. & 2 & Completa \\

4 & Como usuário gostaria de criar eventos para outros usuários participarem. & 3 & Completa \\

5 & Como usuário gostaria de pesquisar outros usuários e eventos na rede para me relacionar. & 3 & Completa \\

6 & Como usuário gostaria de ver usuários sugeridos para facilitar meus relacionamentos. & 2 & Completa \\

7 & ABERTA: Como usuário gostaria de ver um horário em que o maior peso de um conjunto de usuários possa participar para marcar um evento. & 3 & Completa \\

8 & Como usuário gostaria de criar uma rota para melhor controle dos caminhos percorridos. & 8 & Completa \\

9 & ABERTA: Como usuário gostaria de definir um horário de partida para uma rota para melhor controle dos meus compromissos. & 3  & Completa \\

10 & ABERTA: Como usuário gostaria de verificar se algum usuário em um grupo tem uma rota compatível com uma rota específica. & 5 & Completa \\ \bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\end{apendicesenv}
